//baekjoon_3163
//떨어지는 개미

// 1. 개미가 충돌한다고 생각하지 말고, 지나친다고 생각한다.
// 2. 개미의 순서는 변하지 않는다. 거리만 달라질 뿐이다.
// > >  < < < >  의 경우 최종적으로 < < < > > > 이 된다.
// 최초의 <는 최종의 <와 그대로 대응된다.

#include <stdio.h>

int T, N, L, K;

typedef struct st
{
	int id;
	int dist;
}ANT;

ANT Ant[100100];
ANT B[100100];
int POS[100100];

int isMin(ANT a, ANT b)
{
	if (a.dist < b.dist) return 1;
	if (a.dist == b.dist && a.id < b.id) return 1;
	return 0;
}

void merge(int start, int end)
{
	int mid, i, j, k;

	mid = (start + end) / 2;
	i = start;
	j = mid + 1;
	k = 0;

	while (i <= mid && j <= end)
	{
		if (isMin(Ant[i],Ant[j])) B[k++] = Ant[i++];
		else B[k++] = Ant[j++];
	}

	while (i <= mid) B[k++] = Ant[i++];
	while (j <= end) B[k++] = Ant[j++];
	for (i = start; i <= end;i++)
		Ant[i] = B[i - start];

}

void sort(int start, int end)
{
	int mid;
	if (start >= end) return;

	mid = (start + end) / 2;
	sort(start, mid);
	sort(mid + 1, end);
	merge(start, end);
}

int main(void)
{
	int tc, i, k;

	scanf("%d", &T);
	for (tc = 1; tc <= T;tc++)
	{
		int left, right, idx, pidx;
		scanf("%d %d %d", &N, &L, &K);

		left = right = idx = pidx = 0;
		for (i = 0; i < N;i++)
		{
			int pos;
			scanf("%d %d", &pos, &Ant[i].id);
			
			if (Ant[i].id < 0) Ant[idx++].dist = pos;
			else POS[pidx++] = L - pos;
		}

		for (i = 0; i < pidx;i++)
			Ant[idx++].dist = POS[i];

		sort(0, N - 1);
		
		printf("%d\n", Ant[K - 1].id);
	}

	return 0;
}
