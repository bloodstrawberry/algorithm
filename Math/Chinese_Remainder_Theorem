#include <stdio.h>
//중국인의 나머지 정리
//x = b[i] (mod m[i])를 모두 만족하는 최소 x 찾기
//x = b1 * a1 * M / m1 + ... + bi * ai * M / mi
//M = m1 * ... * mi (모두 서로소)
//ai * M / mi = 1 (mod mi)를 만족하는 해 ai;
//ai * M/mi + y*mi = 1 -> 확장 유클리드 방정식 이용

typedef long long int ll;

int T, N, M;
ll A[100]; //m[i]
ll B[100]; //b[i]

gcd(x,y) = ax + by, return gcd, a, b; 
ll Euclid(ll x, ll y, ll& a, ll& b)
{
	if (!y)
	{
		a = 1, b = 0;
		return a;
	}

	ll q = x / y, r = x%y, sp, tp;
	ll g = Euclid(y, r, sp, tp);
	a = tp;
	b = sp - tp*q;

	return x * a + y * b;
}

ll gcd(ll a, ll b)
{
	return (b) ? gcd(b, a%b) : a;
}

int main()
{
	int i, k, tc;
	
	scanf("%d", &T);
	for (tc = 1; tc <= T; tc++)
	{
		scanf("%d", &N);
		for (i = 0; i < N; i++) scanf("%lld %lld", &B[i], &A[i]);

		for (i = 1; i < N; i++)
		{
			ll m1, x1, y1, m2, x2, y2;
			ll M;

			m1 = A[i - 1];
			m2 = A[i];
			M = m1 * m2;

      //서로소가 아닌 경우는 중국인의 나머지 정리를 적용할 수 없다.
      //따라서 해당 gcd만큼 나눠준다.
      //또한 b1 % gcd != b2 % gcd 인 경우는 답이 없다. (x = 2 mod 4, x = 1 mod 6)
      //tc에는 해당 경우가 없음.
			if (gcd(m1, m2) != 1) 
			{
				int tmpGcd = gcd(m1, m2);
				B[i - 1] /= tmpGcd;
				B[i] /= tmpGcd;
			}

			Euclid(m2, m1, y1, x1);
			y1 = (y1 + m1) % m1; //음수 처리

			Euclid(m1, m2, y2, x2);
			y2 = (y2 + m2) % m2; //음수 처리

			B[i] = B[i - 1] * y1 * m2 + B[i] * y2 * m1;
			A[i] = M;
			B[i] %= A[i];
		}

		printf("#%d %lld\n", tc, B[N - 1]);
	}
  
	return 0;
}
